# Очередь на базе кольцевого буфера
## Кольцевой буфер
[![License](https://img.shields.io/badge/LICENSE-The%20Unlicense-green?style=flat-square)](/LICENSE)  [![Version](https://img.shields.io/badge/VERSION-STABLE-green?style=flat-square)](https://github.com/averov90/circular-buffer-Queue/releases)
### :small_orange_diamond: [English version](/README-eng.md)

В данном репозитории представлена реализация очереди на основе кольцевого буфера. 
Использование кольцевого буфера позволяет этой структуре данных быть достаточно эффективной в предполагаемом режиме работы (добавление и удаление в среднем поровну).
Производительность представленной реализации аналогична производительности STL-варианта, скомпилированного в режиме Release (тестирование проводилось на битности x64).

В зависимости от особенностей использования, возможны дополнительные оптимизации некоторых сценариев работы, например, добавления. 
Если оказывается, что временные задержки на расширение структуры слишком велики, возможна реализация кольца более высокого уровня: кольца, содержащего в себе кольца с данными.
Такое решение позволит не использовать потенциально дорогостоящее *memcpy* для большого числа объектов, а также позволит избежать перемещения элементов во время нахождения в структуре (указатель на элемент меняться не будет).

Также возможна оптимизация реверсирования направления очереди. 
Сделать это можно, поменяв местами указатели начала и конца, а также добавив новое поле, в котором будет храниться направление обхода элементов кольца.

#### На базе структуры из *Queue.h* был реализовал класс кольцевого буфера.

Основное отличие по принципу работы состоит в том, что *CircularBuffer.h* не может изменять вмещаемость при переполнении - он просто заменяет наиболее старые элементы.
Однако, в классе *CircularBuffer.h* были добавлены несколько дополнительных функций (*insert* и *erase*, позволяющие выполнить добавление в произвольное место и удаление произвольного улемента), а также полноценная поддержка итерирования. 
Многопроходное итерирование реализовано как вперёд, так и назад. Итератор имеет категорию *bidirectional_iterator_tag* (включает в себя категории *forward_iterator_tag*, *output_iterator_tag*, *input_iterator_tag*).
Был использован "новый" подход создания итератора, когда запрещено наследование от *std::iterator*.

Модификация итератора до расширенной категории *random_access_iterator_tag* может стать хорошей задачей для тренировки.
